import curses
from pyfiglet import Figlet
from typing import NewType
import toml


class Screen():
    '''
    class that controls the initial look of the cli display / general cli display properties
    '''

    cw = NewType('cw', type(curses.initscr()))

    def __init__(self, **kwargs) -> None:
        '''
        Screen class constructor

        :param kwargs: project-wide parameters
        '''

        # initialize program-wide parameters
        self.init_args(**kwargs)

        # initialize command line interface parameters
        self.init_cli()

        # initialize color pallete
        self.init_colors()

        # initialize product name
        self.init_name()
        self.stdscr.refresh()

        # screen size
        y, x = self.screen_size()

        # initialize story window
        story_name = 'story_win'

        # space between header and stories
        self.init_window(y - self.story_start, curses.COLS - 1, self.story_start, 0, story_name)
        self.story_win.box()
        self.window_update(self.story_win)

        # initalize story pad
        self.display_buffer = min(y - self.story_start - 1 - 1, self.display_buffer)

        self.my_pad_pos = 0
        pad_name = 'story_pad'

        self.init_pad(self.buffer, curses.COLS - 1, pad_name)
        self.pad_update(self.story_pad, self.my_pad_pos, 0)


    def init_args(self, **kwargs) -> None: # TODO - change to the comment below
        '''
        initalizing the project-wide parameters

        :param kwargs: project-wide parameters
        :return: nothing
        '''

        '''
        changed = False
        with open('src/config.toml') as f:
            config = toml.load(f)

        for key, value in kwargs.items(): # TODO - change this because it shouldn't change the file
            self.__setattr__(key, value)
            if key in config and config[key] != value:
                config[key] = value
                if not changed:
                    changed = True

        if changed:
            with open('src/config.toml', 'w') as f:
                toml.dump(f, config)
        '''
        for key, value in kwargs.items():
            self.__setattr__(key, value)

    def init_cli(self) -> None:
        '''
        initializing the command line interface parameters

        :return: nothing
        '''

        # initialize curses object
        self.stdscr = curses.initscr()

        # make screen dynamic
        curses.curs_set(0)  # 0, 1, 2 - invisible, normal, or very visible
        self.stdscr.keypad(1)  # if True, escape sequence generated by some keys as opposed to input stream
        curses.mousemask(curses.ALL_MOUSE_EVENTS)

        self.stdscr.nodelay(1)  # True so getch() will be non-blocking

        # for scrolling
        self.stdscr.scrollok(1)  # if true, the window is scrolled up one line also need idlok for natural scrolling
        self.stdscr.idlok(1)

    def init_colors(self) -> None:
        '''
        initializing colors

        :return: nothing
        '''

        # Check for and begin color support
        if curses.has_colors():
            curses.start_color()

        # Initialize the color combinations we are going to use
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)  # foreground, background
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_BLUE, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLACK)

        self.colors = {'red': 1, 'green': 2, 'blue': 3, 'yellow': 4, 'white': 5}

    def init_name(self) -> None: # print header to the screen (banner)
        '''
        prints product title to the command line interface

        :return: nothing
        '''

        f = Figlet(font='slant')
        banner = f.renderText('pnews')
        y = 0
        for line in banner.split('\n'):
            self.stdscr.addstr(y, 0, line)
            y += 1

        self.story_start = y  # line where the stories will start


    def init_window(self, nlines: int, ncols: int, begin_y: int, begin_x: int, name: str) -> None:
        '''
        initializing a curses window

        :param nlines: number of lines for the window
        :param ncols: number of columns for the window
        :param begin_y: y-coordinate for the top left corner of the window
        :param begin_x: x-coordinate for the top left corner of the window
        :param name: name of the window object
        :return: nothing
        '''

        value = curses.newwin(nlines, ncols, begin_y, begin_x)
        self.__setattr__(name, value)

    def init_pad(self, nlines: int, ncols: int, name: str) -> None:
        '''
        initializing a curses pad

        :param nlines: number of lines for the pad
        :type nlines: int
        :param ncols: number of columns for the pad
        :param name: name of the pad object
        :return: nothing
        :rtype: None
        '''

        value = curses.newpad(nlines, ncols)
        self.__setattr__(name, value)

    def window_update(self, window: cw) -> None:
        '''
        updates a curses window

        :param window: window object
        :return: nothing
        '''

        window.refresh()

    def pad_update(self, pad: cw, *position: int) -> None:
        '''
        updates a curses pad

        :param pad: pad object
        :param position: new pad position (y, x)
        :return: nothing
        '''

        self.my_pad_pos, _ = position
        pad.refresh(self.my_pad_pos, 0, self.story_start + 1, 1,
                    self.story_start + self.display_buffer, curses.COLS - 1 - 1 - 1)

    def screen_size(self) -> None:
        '''
        screen size of the command line interface --> (y position, x position)

        :return: nothing
        '''

        return self.stdscr.getmaxyx()


if __name__ == '__main__':

    import tracemalloc
    tracemalloc.start()

    s = Screen()

    current, peak = tracemalloc.get_traced_memory()
    print(f'Current memory usage is {current / 10 ** 6}MB; Peak was {peak / 10 ** 6}MB')
    tracemalloc.stop()






